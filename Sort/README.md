## 정렬
데이터를 특정한 기준에 따라서 순서대로 나열하는 것

프로그램에서 데이터를 가공할 때 오름차순이나 내림차순 등 대부분 어떤 식으로든 정렬해서 사용하는 경우가 많기에
정렬 알고리즘은 프로그램을 작성할 때 가장 많이 사용되는 알고리즘이다.

정렬 알고리즘으로 데이터를 정렬하면 이진 탐색이 가능하다.

### 선택 정렬 (Selection Sort)

![anigif](https://user-images.githubusercontent.com/102349522/210309858-3fa76e7f-22d5-4da3-b933-756773173231.gif)

데이터가 무작위로 여러 개 있을 때, 이중에서 가장 작은 데이터를 선택해 맨 앞에 있는 데이터와 바꾸고, 그 다음 작은 데이터를 선택해 앞에서 두 번째 데이터와 바꾸는 과정을 반복하는 정렬

즉, 매번 '가장 작은 것을 선택한다'는 의미에서 선택 정렬 알고리즘이라고 한다.


시간 복잡도 : O(N^2)

---

### 삽입 정렬 (Insertion Sort)

![anigif2](https://user-images.githubusercontent.com/102349522/210311195-5e786430-63d9-4bd4-92f6-e0370fa5c9d8.gif)

삽입 정렬은 동작 원리를 직관적으로 이해하기 쉬운 알고리즘이다.

삽입 정렬은 필요할 때만 위치를 바꾸므로 '데이터가 거의 정렬되어 있을 때' 훨씬 효율적이다.

삽입 정렬은 특정한 데이터를 적절한 위치에 '삽입'한다는 의미에서 삽입 정렬이라고 부른다.


시간 복잡도 : O(N^2) 
최선의 경우 : O(N)

---

### 퀵 정렬 (Quick Sort)

![anigif3](https://user-images.githubusercontent.com/102349522/210317025-9656e638-246c-4553-92e4-9ae7419c2a35.gif)


퀵 정렬은 지금까지 배운 정렬 알고리즘 중에 가장 많이 사용되는 알고리즘이다.

퀵 정렬은 기준(피벗)을 설정한 다음 큰 수와 작은 수를 교환한 후 리스트를 반으로 나누는 방식으로 동작한다.

[STEP 1]

피벗을 설정한 후 왼쪽에서부터 피벗보다 큰 숫자를 찾고, 오른쪽에서부터 피벗보다 작은 숫자를 찾는다. 그 다음 큰 숫자와 작은 숫자의 위치를 서로 교환한다. 

![step1](https://user-images.githubusercontent.com/102349522/210317500-d8faf16d-0fe0-4eef-8241-245b582ceb76.gif)

[STEP 2]

만약 왼쪽에서 찾은 숫자와 오른쪽에서 찾은 숫자가 서로 교차되면 (왼쪽에서 찾은 수의 index > 오른쪽에서 찾은 수의 index) 

오른쪽에서 찾은 숫자와 피벗을 서로 교환한다. 그러면 피벗보다 왼쪽에 있는 숫자는 모두 피벗보다 작고, 오른쪽에 있는 데이터는 피벗보다 크다.

![step2](https://user-images.githubusercontent.com/102349522/210317509-201636fe-d479-4c9c-af1b-ebb8d28d4821.gif)


시간 복잡도 : O(NlogN)
