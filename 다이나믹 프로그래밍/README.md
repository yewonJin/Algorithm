## 다이나믹 프로그래밍

연산 속도와 메모리 공간을 최대한 활용할 수 있는 효율적인 알고리즘을 작성해야 한다.

다만, 어떤 문제는 메모리 공간을 약간 더 사용하면 연산 속도를 비약적으로 증가시킬 수 있는 방법이 있다.

대표적인 방법이 바로 다이나믹 프로그래밍 기법으로 동적 계획법이라고도 표현한다.

ex) 피보나치 수열

```js
  function fibo(x) {
     if(x === 1 | x === 2) {
        return 1
     }
     return fibo(x-1) + fibo(x-2)
  }
  
  console.log(fibo(4))
```

피보나치 수열의 소스코드를 이렇게 작성하면 문제가 발생할 수 있다.

바로 f(n) 함수에서 n이 커지면 커질 수록 수행 시간이 기하급수적으로 늘어나기 때문이다.

예를 들어 f(10)을 구하려면 f(9) + f(8)을 구해야하고 f(9)를 구하려면 f(8) + f(7)을 구해야하고, f(8)을 구하려면 f(7) + f(6)... 을 구해야하기 때문이다.

이러한 문제는 다이나믹 프로그래밍을 사용하면 수행 시간을 쉽게 해결할 수 있다.

다만, 다음 조건을 만족시킬 때만 사용할 수 있다.
- 큰 문제를 작은 문제로 나눌 수 있다. ex) f(10) = f(9) + f(8), f(9) = f(8) + f(7) ...
- 작은 문제에서 구한 정답은 그것을 포함하는 큰 문제에서도 동일하다.

피보나치 수열은 이러한 조건을 만족하는 대표 문제이다.

## 메모이제이션
메모이제이션은 다이나믹 프로그래밍을 구현하는 방법 중 한 종류로, 한 번 구한 결과를 메모리 공간에 메모해두고 같은 식을 다시 호출하면 메모한 결과를 그대로 가져오는 기법이다.

### Top-Down
```js
  var d = new Array(100).fill(0)
  
  function fibo(x) {
     if(x === 1 | x === 2) {
        return 1
     }
     
     if(d[x] != 0) {
        return d[x]
     }
     
     d[x] = fibo(x-1) + fibo(x-2)
     
     return d[x]
  }
  
  console.log(fibo(10))
```

정리하자면 다이나믹 프로그래밍 방식은 큰 문제를 작게 나누고, 같은 문제라면 한 번씩만 풀어 문제를 효율적으로 해결하는 알고리즘 기법이다.

이처럼 재귀 함수를 이용하여 다이나믹 프로그래밍 소스코드를 작성하는 방법을, 큰 문제를 해결하기 위해 작은 문제를 호출한다고 하여 탑다운 방식이라고 말한다.

### Bottom-Up
```js
  var d = new Array(100).fill(0)
  
  d[1] = 1;
  d[2] = 1;
  var n = 99;
  
  for(let i = 3; i < n + 1; i++) {
    d[i] = d[i-1] + d[i-2]
  }
  
  console.log(d[n]))
```

반면에 단순히 반복문을 이용하여 소스코드를 작성하는 경우 작은 문제부터 차근차근 답을 도출한다고 하여 바텀업 방식이라고 말한다.

